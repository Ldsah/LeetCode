Для начала решу пример:
return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.
Input: nums = [3,10,5,25,2,8]
3 = 11; 10 = 1010; 5 = 101; 25 = 11001; 2 = 10; 8 = 1000
0011^1010 = 1001(9); 011^101 = 110(5); 00011^11001 = 11010(26); 11^10 = 01(1); 0011^1000 = 1011(11). 

Разделю на мелкие подзадачи:
1. Нужно каждое число представить в его двоичном представлении
2. Заведем переменную, в которой будем хранить максимальный разультат операции XOR, изначально равный нулю
3. По массиву начиная с первого числа проходимся по каждому последующему числу и производим XOR с текущим в 
очереди эл-ом
4. Результат каждой опеации сравниваем с текущим максимальным значением операции, если результат выше, чем 
лежащий в переменной, то сохраняем его туда
5. Повторяем пока не пройдем таким образом все элементы, возвращаяя в конце максимальный результат XOR.
Сложность алгоритма: O(n^2).